// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

import oi.limelightvision.limelight.frc.LimeLight;

/**
 *
 * 
 */
public class TurretAim_MM extends SubsystemBase {

    private LimeLight limeLight1;
    private TalonSRX _talon;
    private final double ENCODER_COUNTS_PER_DEG = 905;
    private final double maxDegTravle = 250;
    private final double minTarget = -35;
    private final double maxTarget = minTarget + maxDegTravle;

    /**
    *
    */
    public TurretAim_MM() {

        limeLight1 = new LimeLight("limelight");

        _talon = new WPI_TalonSRX(5);

        /* Factory default hardware to prevent unexpected behavior */
        _talon.configFactoryDefault();

        /* Configure Sensor Source for Pirmary PID */
        _talon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, Constants.kPIDLoopIdx,
                Constants.kTimeoutMs);

        /*
         * set deadband to super small 0.001 (0.1 %). The default deadband is 0.04 (4 %)
         */
        _talon.configNeutralDeadband(0.001, Constants.kTimeoutMs);

        /* Invert Motor? and set Break Mode */
        _talon.setSensorPhase(false);
        _talon.setInverted(true);

        _talon.setNeutralMode(NeutralMode.Coast);

        /* Set relevant frame periods to be at least as fast as periodic rate */
        _talon.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, Constants.kTimeoutMs);
        _talon.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, Constants.kTimeoutMs);

        /* Set the peak and nominal outputs */
        _talon.configNominalOutputForward(0, Constants.kTimeoutMs);
        _talon.configNominalOutputReverse(0, Constants.kTimeoutMs);
        _talon.configPeakOutputForward(.5, Constants.kTimeoutMs);
        _talon.configPeakOutputReverse(-.5, Constants.kTimeoutMs);

        /* Set Motion Magic gains in slot0 - see documentation */
        _talon.selectProfileSlot(Constants.kSlotIdx, Constants.kPIDLoopIdx);
        _talon.config_kF(Constants.kSlotIdx, .009, Constants.kTimeoutMs);
        _talon.config_kP(Constants.kSlotIdx, .09, Constants.kTimeoutMs);
        _talon.config_kI(Constants.kSlotIdx, 0, Constants.kTimeoutMs);
        _talon.config_kD(Constants.kSlotIdx, 0, Constants.kTimeoutMs);

        /* Set acceleration and vcruise velocity - see documentation */
        _talon.configMotionCruiseVelocity(54520, Constants.kTimeoutMs);
        _talon.configMotionAcceleration(181733, Constants.kTimeoutMs);

        /* Zero the sensor once on robot boot up */
        _talon.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("Turret Current Pos", get_currentPos());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void my_Aim_PercentOutput(double percentOutput) {
        _talon.set(ControlMode.PercentOutput, percentOutput);
    }

    public void my_Aim_MotoionMagic(double targetPosDeg) {
        double targetPos = clampTargetPos(targetPosDeg) * ENCODER_COUNTS_PER_DEG;
        _talon.set(ControlMode.MotionMagic, targetPos);

    }

    private double clampTargetPos(double pos) {
        if (pos > (maxTarget - 5)) {
            return maxTarget;
        } else if (pos < (minTarget + 5)) {
            return minTarget;
        } else {
            return pos;
        }
    }

    public void my_SetPos(double sensorPos) {
        _talon.setSelectedSensorPosition(sensorPos);
    }

    public void my_SetPos() {
        _talon.setSelectedSensorPosition(minTarget * ENCODER_COUNTS_PER_DEG);
    }

    public double get_currentPos() {
        return get_My_CurrentRAW_Postion() / ENCODER_COUNTS_PER_DEG;
    }

    private double get_My_CurrentRAW_Postion() {
        return _talon.getSelectedSensorPosition(0);
    }

    public double get_MaxPos() {
        return maxTarget;
    }

    public double get_minPos() {
        return minTarget;
    }

}
