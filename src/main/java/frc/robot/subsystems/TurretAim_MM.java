// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;



/**
 *
 * 
 */
public class TurretAim_MM extends SubsystemBase {

    private boolean ENABLE_FEILD_TRACKING = false;
    private TalonSRX _talon;
    private final double ENCODER_COUNTS_PER_DEG = 885;
    private final double RANGE = 250;
    private final double OFFSET = -37;
    private final double MAXSETPOINT = OFFSET + RANGE;

    /**
    *
    */
    public TurretAim_MM() {

      

        _talon = new WPI_TalonSRX(Constants.kCAN_TurretSpin);

        /* Factory default hardware to prevent unexpected behavior */
        _talon.configFactoryDefault();

        /* Configure Sensor Source for Pirmary PID */
        _talon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, Constants.kPIDLoopIdx,
                Constants.kTimeoutMs);

        /*
         * set deadband to super small 0.001 (0.1 %). The default deadband is 0.04 (4 %)
         */
        _talon.configNeutralDeadband(0.001, Constants.kTimeoutMs);

        /* Invert Motor? and set Break Mode */
        _talon.setSensorPhase(false);
        _talon.setInverted(true);

        _talon.setNeutralMode(NeutralMode.Coast);

        /* Set relevant frame periods to be at least as fast as periodic rate */
        _talon.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, Constants.kTimeoutMs);
        _talon.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, Constants.kTimeoutMs);

        /* Set the peak and nominal outputs */
        _talon.configNominalOutputForward(0, Constants.kTimeoutMs);
        _talon.configNominalOutputReverse(0, Constants.kTimeoutMs);
        _talon.configPeakOutputForward(.5, Constants.kTimeoutMs);
        _talon.configPeakOutputReverse(-.5, Constants.kTimeoutMs);

        /* Set Motion Magic gains in slot0 - see documentation */
        _talon.selectProfileSlot(Constants.kSlotIdx, Constants.kPIDLoopIdx);
        _talon.config_kF(Constants.kSlotIdx, .009, Constants.kTimeoutMs);
        _talon.config_kP(Constants.kSlotIdx, .09, Constants.kTimeoutMs);
        _talon.config_kI(Constants.kSlotIdx, 0, Constants.kTimeoutMs);
        _talon.config_kD(Constants.kSlotIdx, 0, Constants.kTimeoutMs);

        /* Set acceleration and vcruise velocity - see documentation */
        _talon.configMotionCruiseVelocity(54520, Constants.kTimeoutMs);
        _talon.configMotionAcceleration(181733, Constants.kTimeoutMs);

        /* Zero the sensor once on robot boot up */
        //_talon.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        _talon.configClearPositionOnLimitR(true, Constants.kTimeoutMs);
        

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("Turret Current Pos", get_currentPos());
        if(getHomeSwitch()){
            ENABLE_FEILD_TRACKING = true;
        }

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void my_Aim_PercentOutput(double percentOutput) {
        _talon.set(ControlMode.PercentOutput, percentOutput);
    }

    public void my_Aim_MotoionMagic(double targetPosDeg) {
        if(ENABLE_FEILD_TRACKING){
            double targetPos = applySetPointOFFSET(clampTargetPos(targetPosDeg)) * ENCODER_COUNTS_PER_DEG;
            _talon.set(ControlMode.MotionMagic, targetPos);
        }else{
            DriverStation.reportWarning("Must Reference Turret", false);
        }
    }

    private double clampTargetPos(double pos) {
        if (pos > (MAXSETPOINT - 5)) {
            //System.out.println("****************CLAMPING*********************");
            return MAXSETPOINT;
        } else if (pos < (OFFSET + 5)) {
            //System.out.println("**************  clamping *********************");
            return OFFSET;
        } else {
            return pos;
        }
    }

    public void my_SetPos(double sensorPos) {
        _talon.setSelectedSensorPosition((sensorPos  + OFFSET) * ENCODER_COUNTS_PER_DEG);
    }

    //public void my_SetPos() {
    //    _talon.setSelectedSensorPosition(OFFSET * ENCODER_COUNTS_PER_DEG);
    //}

    public double get_currentPos() {
        return (get_My_CurrentRAW_Postion() / ENCODER_COUNTS_PER_DEG) + OFFSET;
    }

    private double get_My_CurrentRAW_Postion() {
        return _talon.getSelectedSensorPosition(0);
    }

    public double get_MaxPos() {
        return MAXSETPOINT;
    }

    public double get_minPos() {
        return OFFSET;
    }

    /**
     * Applies the Offset the Requested Position
     * @param setpoint
     * @return
     */
    private double applySetPointOFFSET(double setpoint){
        return setpoint - OFFSET;
    }

	public boolean getHomeSwitch() {
        if(_talon.isRevLimitSwitchClosed()==1){
            return true;
        }else{
            return false;
        }
		
	}

}
